/**
 * YouTube AI 字幕工具
 * 在 YouTube 视频页面提供 AI 字幕、双语字幕、字幕下载等功能
 */

// 字幕条目
export interface SubtitleEntry {
  start: number  // 开始时间（秒）
  end: number    // 结束时间（秒）
  text: string   // 原文
  translation?: string  // 翻译
}

// 字幕轨道
export interface SubtitleTrack {
  language: string
  languageCode: string
  isAutoGenerated: boolean
  entries: SubtitleEntry[]
}

// 视频信息
export interface YouTubeVideoInfo {
  videoId: string
  title: string
  channelName: string
  duration: number
  description?: string
}

// 检测是否为 YouTube 视频页面
export function isYouTubePage(): boolean {
  return window.location.hostname.includes('youtube.com')
}

// 检测是否为视频播放页面
export function isYouTubeWatchPage(): boolean {
  return isYouTubePage() && window.location.pathname === '/watch'
}

// 获取视频 ID
export function getVideoId(): string | null {
  const urlParams = new URLSearchParams(window.location.search)
  return urlParams.get('v')
}

// 获取视频信息
export function getVideoInfo(): YouTubeVideoInfo | null {
  if (!isYouTubeWatchPage()) return null
  
  const videoId = getVideoId()
  if (!videoId) return null
  
  try {
    // 获取标题
    const titleEl = document.querySelector('h1.ytd-video-primary-info-renderer yt-formatted-string, h1.ytd-watch-metadata yt-formatted-string') as HTMLElement
    const title = titleEl?.textContent?.trim() || document.title.replace(' - YouTube', '')
    
    // 获取频道名
    const channelEl = document.querySelector('#channel-name a, ytd-channel-name a') as HTMLElement
    const channelName = channelEl?.textContent?.trim() || ''
    
    // 获取视频时长
    const video = document.querySelector('video') as HTMLVideoElement
    const duration = video?.duration || 0
    
    // 获取描述
    const descEl = document.querySelector('#description-inline-expander, #description') as HTMLElement
    const description = descEl?.textContent?.trim().slice(0, 500) || ''
    
    return {
      videoId,
      title,
      channelName,
      duration,
      description
    }
  } catch (e) {
    console.error('获取视频信息失败:', e)
    return null
  }
}

// 获取当前播放时间
export function getCurrentTime(): number {
  const video = document.querySelector('video') as HTMLVideoElement
  return video?.currentTime || 0
}

// 跳转到指定时间
export function seekTo(time: number): void {
  const video = document.querySelector('video') as HTMLVideoElement
  if (video) {
    video.currentTime = time
  }
}

// 格式化时间为 SRT 格式
export function formatSrtTime(seconds: number): string {
  const h = Math.floor(seconds / 3600)
  const m = Math.floor((seconds % 3600) / 60)
  const s = Math.floor(seconds % 60)
  const ms = Math.floor((seconds % 1) * 1000)
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`
}

// 格式化时间为显示格式
export function formatDisplayTime(seconds: number): string {
  const m = Math.floor(seconds / 60)
  const s = Math.floor(seconds % 60)
  return `${m}:${s.toString().padStart(2, '0')}`
}

// 导出为 SRT 格式
export function exportToSrt(entries: SubtitleEntry[], includeBilingual: boolean = false): string {
  return entries.map((entry, index) => {
    const startTime = formatSrtTime(entry.start)
    const endTime = formatSrtTime(entry.end)
    let text = entry.text
    if (includeBilingual && entry.translation) {
      text = `${entry.text}\n${entry.translation}`
    }
    return `${index + 1}\n${startTime} --> ${endTime}\n${text}\n`
  }).join('\n')
}

// 导出为 VTT 格式
export function exportToVtt(entries: SubtitleEntry[], includeBilingual: boolean = false): string {
  const vttTime = (seconds: number) => formatSrtTime(seconds).replace(',', '.')
  
  let vtt = 'WEBVTT\n\n'
  entries.forEach((entry, index) => {
    const startTime = vttTime(entry.start)
    const endTime = vttTime(entry.end)
    let text = entry.text
    if (includeBilingual && entry.translation) {
      text = `${entry.text}\n${entry.translation}`
    }
    vtt += `${index + 1}\n${startTime} --> ${endTime}\n${text}\n\n`
  })
  return vtt
}

// 导出为纯文本
export function exportToText(entries: SubtitleEntry[], includeBilingual: boolean = false): string {
  return entries.map(entry => {
    if (includeBilingual && entry.translation) {
      return `${entry.text}\n${entry.translation}`
    }
    return entry.text
  }).join('\n\n')
}

// 下载文件
export function downloadFile(content: string, filename: string, mimeType: string = 'text/plain'): void {
  const blob = new Blob([content], { type: mimeType })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

// 尝试获取 YouTube 原生字幕
export async function fetchYouTubeSubtitles(_videoId: string): Promise<SubtitleEntry[] | null> {
  try {
    // 尝试从页面数据中获取字幕 URL
    const scripts = document.querySelectorAll('script')
    let captionTracks: { baseUrl: string; languageCode: string }[] = []
    
    for (const script of scripts) {
      const content = script.textContent || ''
      if (content.includes('captionTracks')) {
        const match = content.match(/"captionTracks":\s*(\[.*?\])/s)
        if (match) {
          try {
            captionTracks = JSON.parse(match[1])
          } catch {
            // 解析失败，继续尝试其他方式
          }
        }
      }
    }
    
    if (captionTracks.length === 0) {
      return null
    }
    
    // 优先选择英文或自动生成的字幕
    const track = captionTracks.find(t => t.languageCode === 'en') || captionTracks[0]
    if (!track?.baseUrl) return null
    
    // 获取字幕内容
    const response = await fetch(track.baseUrl)
    const xml = await response.text()
    
    // 解析 XML 字幕
    const parser = new DOMParser()
    const doc = parser.parseFromString(xml, 'text/xml')
    const textElements = doc.querySelectorAll('text')
    
    const entries: SubtitleEntry[] = []
    textElements.forEach((el) => {
      const start = parseFloat(el.getAttribute('start') || '0')
      const dur = parseFloat(el.getAttribute('dur') || '2')
      const text = el.textContent?.replace(/&#39;/g, "'").replace(/&quot;/g, '"').replace(/&amp;/g, '&') || ''
      
      entries.push({
        start,
        end: start + dur,
        text: text.trim()
      })
    })
    
    return entries
  } catch (e) {
    console.error('获取 YouTube 字幕失败:', e)
    return null
  }
}

// 生成 AI 字幕提示词（用于音频转文字）
export function generateTranscriptionPrompt(videoInfo: YouTubeVideoInfo): string {
  return `请为以下 YouTube 视频生成字幕/转录文本。

视频信息：
- 标题: ${videoInfo.title}
- 频道: ${videoInfo.channelName}
- 时长: ${formatDisplayTime(videoInfo.duration)}
- 描述: ${videoInfo.description || '无'}

请根据视频内容生成准确的字幕文本。`
}

// 生成翻译提示词
export function generateTranslationPrompt(text: string, targetLang: string = '中文'): string {
  return `请将以下字幕内容翻译成${targetLang}，保持原有的语气和风格，翻译要自然流畅：

${text}

要求：
1. 保持原意，翻译准确
2. 语言自然，符合${targetLang}表达习惯
3. 专业术语保持准确
4. 只输出翻译结果，不要添加解释`
}

// 生成视频总结提示词
export function generateVideoSummaryPrompt(videoInfo: YouTubeVideoInfo, subtitles: string): string {
  return `请根据以下 YouTube 视频的字幕内容，生成一份结构化的视频总结。

视频信息：
- 标题: ${videoInfo.title}
- 频道: ${videoInfo.channelName}
- 时长: ${formatDisplayTime(videoInfo.duration)}

字幕内容：
${subtitles.slice(0, 8000)}

请生成以下内容：
1. **一句话总结**：用一句话概括视频主题（20字以内）
2. **核心要点**：列出 3-5 个视频的核心观点或要点
3. **详细总结**：200-300 字的详细内容总结
4. **关键时间点**：如果有明显的章节或话题转换，列出关键时间点
5. **适合人群**：这个视频适合什么样的观众

请用中文回答。`
}

// 字幕面板配置
export interface SubtitlePanelConfig {
  enabled: boolean
  autoBilingual: boolean
  targetLanguage: string
  fontSize: number
  position: 'bottom' | 'side'
}

// 默认配置
export const DEFAULT_SUBTITLE_CONFIG: SubtitlePanelConfig = {
  enabled: true,
  autoBilingual: true,
  targetLanguage: '中文',
  fontSize: 14,
  position: 'bottom'
}

// 保存配置
export async function saveSubtitleConfig(config: SubtitlePanelConfig): Promise<void> {
  await chrome.storage.sync.set({ youtubeSubtitleConfig: config })
}

// 加载配置
export async function loadSubtitleConfig(): Promise<SubtitlePanelConfig> {
  const result = await chrome.storage.sync.get(['youtubeSubtitleConfig'])
  return { ...DEFAULT_SUBTITLE_CONFIG, ...result.youtubeSubtitleConfig }
}
